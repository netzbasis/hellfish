#!/bin/sh

### includes ###
. ./files/scripts/Helper.sh
. ./files/scripts/DebugPrint.sh
. ./files/conf/hf.conf

### functions ###
# $@ all parameters
hf_main() {
	dpush "main"
	case "$1" in
		cvsync|cs) hf_cvsync "$2";;
		cvs) hf_cvs_up "$2";;
		pull) hf_pull;;
		push) hf_push;;
		kernel|ke) hf_make_kernel "$2";;
		userland|us) hf_make_build;;
		xenocara|xe) hf_make_xenocara;;
		hellfish|hf) hf_recreate_exp_branch "$2";;
		cmd) hf_command "$2";;
		clean|cl) hf_clean "$2";;
		reset|re) hf_reset "$2";;
		bsd.rd|rd) hf_download_bsdrd "$2";;
		upgrade|up) hf_upgrade "$2" "$3";;
		info) hf_info;;
		run) hf_run "$@";; #test hook for new functions
		*) hf_usage;;
	esac
	[ "x$3" = "x-r" ] && hf__command "./" "$SUDO reboot&"
	dpop
}

hf_usage() {
	dpush "usage"
	cat <<EOF
usage: $0 <command> [option] "input"
available commands (aliases)
cvsync (cs): sync cvs repos and git repos
	[-p] push git repos after sync
cvs: make git workdirs cvs compatible
	[-s] first sync cvs repo, but not git
pull: pull all git repos
push: push all git repos
kernel (ke): build kernel
	[-i] install
	[-r] reboot
userland (us): build userland
xenocara (xe): build xenocara
hellfish (hf): recreate experimental branch
	[-p] pull first
	[-d] delete experimental branch
cmd: execute command in all submodules
clean (cl): clean untracked files
	[-a] also clean hellfish repo
reset (re): reset uncommited changes
	[-a] also reset hellfish repo
bsd.rd (rd): download and install bsd.rd
	[-u] also prepare for auto_upgrade
upgrade (up): download sets and kernels
	[-a] <arch> download sets for arch
	[-u] upgrade system after download (the wrong way!)
	[-r] reboot
info: show info
EOF
	dpop
}

# $@ all parameters
hf_run() {
	dpush "run"
	$2 "$3" "$4" "$5"
	dpop
}

# $1 cmd, $2 max_return_status
hf_command() {
	dpush "command"
	hf__command "$SRCNAME" "$1" "$2"
	hf__command "$XENOCARANAME" "$1" "$2"
	hf__command "$PORTSNAME" "$1" "$2"
	hf__command "$WWWNAME" "$1" "$2"
	dpop
}

# $1 directory, $2 cmd, $3 max_return_status
hf__command() {
	dpush "_command"
	[ -z "$3" ] && ERR=0 || ERR="$3"
	echo "===> PWD $COLOR2$1$COLORR CMD $COLOR1$2$COLORR <==="
	sleep 1
	cd "$1"
	    [ $? -gt 0 ] && hf_error 128
	eval $2
	RET=$?
	    [ $RET -gt $ERR ] && ERRCMD="$2" && hf_error $RET
	cd "$HFDIR"
	    [ $? -gt 0 ] && hf_error 127
	dpop
}

hf_info() {
	dpush "info"
	hf_command "git branch"
	dpop
}

# $1 clean_all_flag
hf_clean() {
	dpush "clean"
	[ "x$1" = "x-a" ] && hf__command "./" "git clean -xdf"
	hf_command "git clean -xdf >/dev/null"
	dpop
}

# $1 reset_all_flag
hf_reset() {
	dpush "reset"
	[ "x$1" = "x-a" ] && hf__command "./" "git reset --hard"
	hf_command "git reset --hard"
	dpop
}

# $1 delete flag
hf_recreate_exp_branch() {
	dpush "recreate_exp_branch"
	[ "x$1" = "x-p" ] && hf_pull

	hf_command "git checkout master"
	hf_command "git branch -D $EXPERIMENTAL_BRANCH" 1
	hf_command "git push origin :$EXPERIMENTAL_BRANCH" 1

	[ "x$1" = "x-d" ] && return

	hf_command "git checkout -b $EXPERIMENTAL_BRANCH"
	hf_command "git branch 2>/dev/null | grep 'hf-' | cut -c 3- | while read line; do git merge --no-ff -m \"Merge \$line into $EXPERIMENTAL_BRANCH\" \$line; done"
	dpop
}

hf_make_xenocara() {
	dpush "make_xenocara"
	hf_fill_githash_for_logging $XENOCARANAME
	hf__command "$XOBJDIR" "rm -rf *"
	hf__command "$XENOCARANAME" "make clean"
	hf__command "$XENOCARANAME" "make obj"
	hf__command "$XENOCARANAME" "make bootstrap"
	hf__command "$XENOCARANAME" "make build | tee -a ${LOG_FILE}"
	dpop
}

hf_make_build() {
	dpush "make_build"
	hf_fill_githash_for_logging $SRCNAME
	hf__command "$BSDOBJDIR" "rm -rf *"
	hf__command "$SRCNAME" "make clean"
	hf__command "$SRCNAME" "make obj"
	hf__command "$SRCNAME/etc" "$SUDO env DESTDIR=/ make distrib-dirs"
	hf__command "$SRCNAME" "make build | tee -a ${LOG_FILE}"
	dpop
}

# $1 install
hf_make_kernel() {
	dpush "make_kernel"
	hf_fill_githash_for_logging $SRCNAME

	HELLFILE=${BSDSRCDIR}/sys/arch/${ARCH}/conf/$EXPERIMENTAL_KERNEL
	[ -f ${HELLFILE} ] && KERNEL=$EXPERIMENTAL_KERNEL

	hf__command "${BSDSRCDIR}/sys/arch/${ARCH}/conf" "config $KERNEL"
	hf__command "${BSDSRCDIR}/sys/arch/${ARCH}/compile/$KERNEL" "make clean"

	[ -f ${HELLFILE} ] && [ -f ${HFTEMP}/version ] && cp ${HFTEMP}/version ${BSDSRCDIR}/sys/arch/${ARCH}/compile/$KERNEL/version

	hf__command "${BSDSRCDIR}/sys/arch/${ARCH}/compile/$KERNEL" "make | tee -a ${LOG_FILE}"

	[ -f ${HELLFILE} ] && cp ${BSDSRCDIR}/sys/arch/${ARCH}/compile/$KERNEL/version ${HFTEMP}/version

	[ "x$1" = "x-i" ] && hf__command "${BSDSRCDIR}/sys/arch/${ARCH}/compile/$KERNEL" "$SUDO make install"
	dpop
}

# $1 cvsync
hf_cvs_up() {
	dpush "cvs_up"
	[ "x$1" == "x-s" ] && hf_cvsync_only

	hf_create_cvs_folders $SRCNAME
	hf_create_cvs_folders $PORTSNAME
	hf_create_cvs_folders $WWWNAME
	hf_create_cvs_folders $XENOCARANAME

	hf_command "cvs -d $CVSROOT up -Pd >> $CVSYNC_LOG_FILE 2>&1" 1
	dpop
}

# $1 subfolder
hf_create_cvs_folders() {
	dpush "create_cvs_folders"
	find $1 -type d | while read line
	do
		mkdir $line/CVS &&
		echo "$CVSROOT" > $line/CVS/Root &&
		echo "$line" > $line/CVS/Repository &&
		touch $line/CVS/Entries
	done
	dpop
}

hf_push() {
	dpush "push"
	hf_command "git push --all"
	hf__command "./" "git push"
	dpop
}

hf_pull() {
	dpush "pull"
	hf__command "./" "git fetch --all -p"
	hf_command "git fetch --all -p"
	hf__command "./" "git checkout master"
	hf_command "git checkout master"
	hf__command "./" "git pull"
	hf_command "git pull"
	dpop
}

hf_cvsync_only() {
	dpush "cvsync_only"
	hf__command "./" "cvsync -c $CVSYNCCONF >> $CVSYNC_LOG_FILE"
	dpop
}

# $1 push
hf_cvsync() {
	dpush "cvsync"
	hf_cvsync_only
	hf_pull
	hf_command "rm -rf *"

	hf_cvs_checkout
	hf_commit_all

	[ "x$1" == "x-p" ] && hf_push
	dpop
}

hf_cvs_checkout() {
	dpush "cvs_cehckout"
	hf__command "./" "cvs -d $CVSROOT co -P $SRCNAME >> $CVSYNC_LOG_FILE 2>&1" 1
	hf__command "./" "cvs -d $CVSROOT co -P $PORTSNAME >> $CVSYNC_LOG_FILE 2>&1" 1
	hf__command "./" "cvs -d $CVSROOT co -P $XENOCARANAME >> $CVSYNC_LOG_FILE 2>&1" 1
	hf__command "./" "cvs -d $CVSROOT co -P $WWWNAME >> $CVSYNC_LOG_FILE 2>&1" 1
	dpop
}

hf_commit_all() {
	dpush "commit_all"
	hf_command "git add -A :/ >> $CVSYNC_LOG_FILE"
	hf_command "git commit -m 'sync with openbsd-current' >> $CVSYNC_LOG_FILE 2>&1" 1
	dpop
}

# $1 install sets flag OR arch flag $2 optional arch name
hf_upgrade() {
	dpush "upgrade"
	[ "x$1" == "x-a" ] && export ARCH=$2  &&
	    export DOWNL=$MIRROR/$ARCH &&
	    export HFTEMPDATE=$HFTEMPDATE/$ARCH
	hf_get_verify_filelist
	hf__command "$HFTEMPDATE" "while read line; do ftp -C $DOWNL/\$line; done < file.list" 1
	hf__command "$HFTEMPDATE" "while read line; do sha256 -C SHA256 \$line; done < file.list"

	hf__command "$HFTEMP" "rm last" 1
	hf__command "$HFTEMP" "ln -s $FORMATEDDATE last"

	[ "x$1" == "x-u" ] && hf__command "$HFTEMPDATE" "$SUDO $HFDIR/files/scripts/Upgrade.sh"
	dpop
}

# $1 auto_upgrade flag
hf_download_bsdrd() {
	dpush "download_bsdrd"
	A=""

	hf_get_verify_filelist
	hf__command "$HFTEMPDATE" "ftp -C $DOWNL/bsd.rd" 1
	hf__command "$HFTEMPDATE" "sha256 -C SHA256 bsd.rd"

	[ "x$1" == "x-u" ] && hf_auto_bsdrd && A=a

	hf__command "$HFTEMPDATE" "$SUDO cp bsd.rd$A /bsd.rd"
	dpop
}

hf_auto_bsdrd() {
	dpush "auto_bsdrd"
	hf__command "$HFTEMPDATE" "mkdir root" 1
	hf__command "$HFTEMPDATE" "cp bsd.rd bsd.rda"
	hf__command "./" "gcc -o rdsetroot src/distrib/common/elf{32,64,rdsetroot}.c"
	hf__command "$HFTEMPDATE" "$HFDIR/rdsetroot -dx bsd.rda root.fs"
	hf__command "$HFTEMPDATE" "$SUDO vnconfig vnd3 root.fs"
	hf__command "$HFTEMPDATE" "$SUDO mount /dev/vnd3a $HFTEMPDATE/root"
	hf__command "./" "$SUDO cp files/conf/auto_upgrade.conf $HFTEMPDATE/root"
	hf__command "$HFTEMPDATE" "$SUDO umount /dev/vnd3a"
	hf__command "$HFTEMPDATE" "$SUDO vnconfig -u vnd3"
	hf__command "$HFTEMPDATE" "$HFDIR/rdsetroot -d bsd.rda root.fs"
	dpop
}

hf_get_verify_filelist() {
	dpush "get_verify_filelist"
	hf__command "./" "mkdir -p -m 744 $HFTEMPDATE"
	hf__command "$HFTEMPDATE" "ftp $DOWNL/SHA256.sig"
	hf__command "$HFTEMPDATE" "signify -Vep $BASEPUBKEY -x SHA256.sig -m SHA256"
	hf__command "$HFTEMPDATE" "cut -d ' ' -f 2 SHA256 | tr -d '(' | tr -d ')' | grep -v -e install -e SHA256 > file.list"
	dpop
}

# $1 return value
hf_error() {
	echo "ERROR: $(__stop_timer) $DEBUG_PRINT_STACK $1" >> $TIME_LOG_FILE
	[ -n "$ERRCMD" ] && echo "ERRCMD: $ERRCMD" | tee -a $TIME_LOG_FILE
	ERRCMD=""
	dprint_trace_exit_if_error $1
}

# $1 module name
hf_fill_githash_for_logging() {
	GITHASH=`cd $HFDIR/$1 && git rev-parse HEAD`
}

# $1 lenght of lines to keep $2 min size in kb to truncate
hf_truncate_logs() {
	for file in *.err.log
	do
		[ $file = "*.err.log" ] && break
		SIZE=$(du -k $file | cut -f1)
		if [ $SIZE -ge $2 ]
		then
			tail -$1 $file > xxx.err.log
			mv xxx.err.log $file
		fi
	done
}

### main ###
GITHASH=""
FORMATEDDATE=$(__get_formated_date)
HFTEMPDATE=$HFTEMP/$FORMATEDDATE
COLOR1=$(./files/scripts/TerminalColorEscapes.sh red - bold)
COLOR2=$(./files/scripts/TerminalColorEscapes.sh magenta)
COLORR=$(./files/scripts/TerminalColorEscapes.sh reset)
__start_timer

hf_main "$@"
hf_truncate_logs 100000 40000

echo "$(__stop_timer) $@ $GITHASH" >> $TIME_LOG_FILE
echo "===> time elapsed $(__stop_timer) <==="

exit 0

